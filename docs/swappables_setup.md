# Overview
To allow for simpler code reuse and updating for specific study parameters swappable models have been implemented on Participant and AutomatedMessage Models.  Swappable models allow models to be overidden without breaking DB relations to the parent model in a manner similar to the Django user Profile pattern.  Documentaiton and details here:  https://github.com/wq/django-swappable-models  

# Implementation
Basic impementation instructions.  Examples of one implementation is available in the mwhiv app.

## Models
To overide a swapable model when developing a new customized version of the mwach app the developer will subclass the ParticipantBase or AutomatedMessageBase.  These should be placed in a new django app inside the project.  Any customizations to these models are made on the subclassed models by adding fields or overiding/adding methods.  In most cases custom querysets and managers will also be implemented.  Depending on the logic needed for a given study __init__(), save(), and description() are the most likely methods to require being overidden on the Participant Model, as well as any variations on the choices stored on the model.  AutomatedMessage custom models will likely need description() and category() methods overidden as well as the queryset and manager.  If custom status change reporting is needed (as in mwachx) the StatusChange model is also swapable.  Exact needs will vary on the needs of the study being implemented of course.  Ensure the custom class meta: app_label is correctly set to the custom app on all custom models.

## Forms, Views, and Templates
Any changes to the participant model will need to be reflected in an updated set of forms, that custom views can import for display and admin templates for the smsbank import pointing to the correct django module cor any custom automated message models.  Most of this is boilerplate just ensuring all the references are to the custom module not the original and that forms include any added fields.  Some of it might be achievable via settings but more flexibiity and expandability is allowed if they are part of the module. 

Templates placed in the correct path in static within a custom module will overide the mwbase html template if STATICFILES_DIRS is set to include that path (IE STATICFILES_DIRS = [f'{PROJECT_ROOT}/mwpriya/static', f'{PROJECT_ROOT}/mwbase/static'] will hae the templates int he priya static directory overide) This allows the participant details and participant list and other areas to be overidden.  In several places a modular approach has been taken utilizing ng-include so the entire file will not always need to be replicated to make changes in one area.  See static/app/participantDetail/participantDetail.html, participantDetailHeader.html, and participantDetailTable.html for examples.

## Serializers and urls for Angular
Any custom model subject to Angular api calls, such as Participant, will need to have a serializer for it implemented.  The Serialzer(s) should be included in the custom app in thier own file/folder.  The serializer will need both the serializer and an implementation of the model viewset.  Both should inherit from the mwbase serializers/viewset for that model/viewset and implement any aditional fields to be serialized. Add any methods required for specific study logic and be set to the custom models not the swappable base or default.   Viewsets should assign custom forms that include any aditional fields for create and update and an get_serializer_class that selects the correct custom serializer.

The serializers file or folder init file should implement the rest_framework router including all the base routers and updating any custom viewsets to be registered in place of the base ones.  Most likely just Participants.  The custom modules urls.py should replicate the base urls.py but import the custom router fro the apr/v0.1/ route, and the updated crispyforms views for the custom forms.
finally a new urlconf in mwach/urls should be made with a custom name that will include the common_urlpatterns and add the custom module urls to the paterns list. (hiv.py is an example)

Datefields will need to have the convert_form_date function run on them in the related js file for the form for add participant.

## Settings
A custom settings file will need to be made for any custom app.  The custom settings should first import settings_base to get the core django settings used across all apps.  Then the custom settigns will need to add the custom module to INSTALLED_APPS and ser URL_CONF to the custom urlconf added above.  Swappable and Inherited classes will also need to be settings defined.  Currently those are defined as SMSBANK_CLASS, MWBASE_AUTOMATEDMESSAGE_MODEL, MWBASE_PARTICIPANT_MODEL, and MWBASE_STATUSCHANGE_MODEL.  Each set to the string defined model or class location. '<module>.<model>' for swapped models, '<module>.<component>.<class>' for SMSBANK_CLASS.  Lastly local_settings.py should be built to import the custom settings file and add any server specific settings such as DEBUG or ALLOWED_HOSTS.  Settings also will hold the options for cross model selections like facility, study_group, and inactive criteria such as no_sms etc.  See settings_base.py for examples.

If custom templates are in use the module specific settigns file will need to include STATICFILES_DIRS.  If Facilities, study groups, or inactive status for SMS or Preg status vary they will need to be defined in the module specific settigns file see settings_base for examples.  If not all the filter buttons will be in use the module settigns should include an accurate list under FILTER_LIST.